const e = require('express');
const db = require('../index');


exports.getAllEvents = (req, res) => {
    db.query('SELECT * FROM Evenement', (err, results) => {
        if (err) {
        return res.status(500).json({ error: 'Erreur MySQL' });
        }
        res.json(results);
    });
}

const fs = require('fs');
const path = require('path');

function getMapPoints(filePath) {
  const rawData = fs.readFileSync(filePath, 'utf-8');
  const lines = rawData.trim().split('\n');

  const points = lines.map(line => {
    const [xStr, yStr, rawName] = line.split(';');
    return {
      x: parseInt(xStr, 10),
      y: parseInt(yStr, 10),
      name: rawName.replace(/@/g, ' ')
    };
  });

  return points;
}

function parseGraph(filePath) {
  const fullPath = path.join(__dirname, '..', filePath);
  const data = fs.readFileSync(fullPath, 'utf-8');
  const lines = data.split('\n').filter(line => line.trim() !== '');
  const nodes = [];
  const edges = [];

  for (const line of lines) {
    const parts = line.split(';').map(p => p.trim());
    if (line.startsWith('V')) {
      const id = parts[1];
      const name = parts.slice(2, parts.length-5).join(' ');
      const lineNumber = parts[parts.length-4];
      const terminus = parts[parts.length-2] === 'True';
      const branch = parseInt(parts[parts.length-1]);
      nodes.push({ id, name, line: lineNumber, terminus, branch });
    } else if (line.startsWith('E')) {
      const parts = line.split(';');
      edges.push({
        from: parts[1],
        to: parts[2],
        time: parseInt(parts[3])
      });
    }
  }
  return { nodes, edges };
}



// Parse le fichier des positions
function parsePointPositions(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split('\n');

  const map = new Map();

  for (const line of lines) {
    const [x, y, rawName] = line.split(';');
    if (!x || !y || !rawName) continue;

    const name = rawName.replace(/@/g, ' ').trim();
    map.set(name, { x: parseInt(x, 10), y: parseInt(y, 10) });
  }

  return map;
}

function getLinks(edges, nodeMap) {
  return edges
    .filter(edge => nodeMap[edge.from] && nodeMap[edge.to])
    .map(edge => ({
      from: { id: edge.from, ...nodeMap[edge.from] },
      to: { id: edge.to, ...nodeMap[edge.to] },
      time: edge.time
    }));
}

function dijkstra(nodes,edges, start, end) {
  var visited_node = [];
  var min_dist = [];
  for(let i = 0; i < nodes.length; i++) {
    min_dist[i] = Infinity;
  }
  min_dist[nodes.findIndex(node => parseInt(node.id) === parseInt(start))] = 0;
  while(visited_node.length < nodes.length) {
    var min = Infinity;
    var noeud_courant = -1;
    for(let i = 0; i < nodes.length; i++) {
      if(!visited_node.includes(i) && min_dist[i] < min) {
        min = min_dist[i];
        noeud_courant = i;
      }
    }
    visited_node.push(min_index);
    for(let edge of edges) {
      if(edge.from === nodes[min_index].id && !visited_node.includes(nodes.findIndex(node => node.id === edge.to))) {
        const toIndex = nodes.findIndex(node => node.id === edge.to);
        if(min_dist[min_index] + edge.time < min_dist[toIndex]) {
          min_dist[toIndex] = min_dist[min_index] + edge.time;
        }
      }
    }
  }
  return min_dist;
}

module.exports = {
  getMapPoints,
  getLinks,
  parseGraph,
  parsePointPositions,
  dijkstra
};