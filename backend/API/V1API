const e = require('express');
const db = require('../index');

const fs = require('fs');
const path = require('path');

function getMapPoints(filePath) {
  const rawData = fs.readFileSync(filePath, 'utf-8');
  const lines = rawData.trim().split('\n');

  const points = lines.map(line => {
    const [xStr, yStr, rawName] = line.split(';');
    return {
      x: parseInt(xStr, 10),
      y: parseInt(yStr, 10),
      name: rawName.replace(/@/g, ' ')
    };
  });

  return points;
}

function parseGraph(filePath) {
  const fullPath = path.join(__dirname, '..', filePath);
  const data = fs.readFileSync(fullPath, 'utf-8');
  const lines = data.split('\n').filter(line => line.trim() !== '');
  const nodes = [];
  const edges = [];

  for (const line of lines) {
    const parts = line.split(';').map(p => p.trim());
    if (line.startsWith('V')) {
      const id = parts[1];
      const name = parts.slice(2, parts.length-5).join(' ');
      const lineNumber = parts[parts.length-4];
      const terminus = parts[parts.length-2] === 'True';
      const branch = parseInt(parts[parts.length-1]);
      nodes.push({ id, name, line: lineNumber, terminus, branch });
    } else if (line.startsWith('E')) {
      const parts = line.split(';');
      edges.push({
        from: parts[1],
        to: parts[2],
        time: parseInt(parts[3])
      });
    }
  }
  return { nodes, edges };
}



// Parse le fichier des positions
function parsePointPositions(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.split('\n');

  const map = new Map();

  for (const line of lines) {
    const [x, y, rawName] = line.split(';');
    if (!x || !y || !rawName) continue;

    const name = rawName.replace(/@/g, ' ').trim();
    map.set(name, { x: parseInt(x, 10), y: parseInt(y, 10) });
  }

  return map;
}

function getLinks(edges, nodeMap) {
  return edges
    .filter(edge => nodeMap[edge.from] && nodeMap[edge.to])
    .map(edge => ({
      from: { id: edge.from, ...nodeMap[edge.from] },
      to: { id: edge.to, ...nodeMap[edge.to] },
      time: edge.time
    }));
}

function computeShortestPath(nodes, edges, start, end) {
  var visited_node = [];
  var min_dist = [];
  var prev_nodes = [];

  // Initialiser les distances minimales et les nœuds précédents
  for (let i = 0; i < nodes.length; i++) {
    min_dist[i] = Infinity;
    prev_nodes[i] = null;
  }

  // La distance du nœud de départ à lui-même est zéro
  let startIndex = nodes.findIndex(node => String(node.id).trim() === String(start).trim());

  min_dist[startIndex] = 0;

  while (visited_node.length < nodes.length) {
    let min = Infinity;
    let noeud_courant = null;

    for (let i = 0; i < nodes.length; i++) {
      if (!visited_node.includes(i) && min_dist[i] < min) {
        min = min_dist[i];
        noeud_courant = i;
      }
    }
    if (noeud_courant === null) {
      break; // Tous les nœuds visités ou plus de connexions
    }
    visited_node.push(noeud_courant);
    if (nodes[noeud_courant].id === end) {
      break; // Arrêter si on atteint le nœud de destination
    }
    // Mettre à jour les distances minimales et les nœuds précédents
    for (let i = 0; i < edges.length; i++) {
      if (edges[i].from === nodes[noeud_courant].id && !visited_node.includes(nodes.findIndex(node => node.id === edges[i].to))) {
        let neighborIndex = nodes.findIndex(node => node.id === edges[i].to);
        let newDist = min_dist[noeud_courant] + edges[i].time;
        if (newDist < min_dist[neighborIndex]) {
          min_dist[neighborIndex] = newDist;
          prev_nodes[neighborIndex] = noeud_courant;
        }
      }
    }
  }
  // Reconstruire le chemin le plus court
  let path = [];
  let currentIndex = nodes.findIndex(node => node.id === end);
  while (currentIndex !== null) {
    path.unshift(nodes[currentIndex].id);
    currentIndex = prev_nodes[currentIndex];
  }
  return path;
}


module.exports = {
  getMapPoints,
  getLinks,
  parseGraph,
  parsePointPositions,
  computeShortestPath
};